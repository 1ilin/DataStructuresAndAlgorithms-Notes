## 重点
插入排序类、交换排序类、选择排序类、归并排序类、基数排序的思想和算法。
## 难点
堆排序的思想和算法，在实际应用中如何根据实际情况，选择最优的排序算法。

# 概述
---
## 排序方法的稳定性
当排序的关键字中存在相同的情况时,排序的结果不唯一;	
	在排序前后，含相等关键字的记录的**相对位置保持不变**，称这种排序方法是**稳定**的；
	反之，含相等关键字的记录的**相对位置有可能改变**，则称这种排序方法是**不稳定**的。

## 内部、外部排序
在排序过程中，只使用计算机的**内存**存放待排序记录，称这种排序为**内部排序**。
排序期间文件的全部记录不能同时存放在计算机的内存中，要借助计算机的**外存**才能完成排序，称之为**外部排序**。
内外存之间的数据交换次数是影响外部排序速度的主要因素。

>软工这学期不涉及外部排序

## 存储结构
```c
#define MAXSIZE 1000 // 待排顺序表最大长度
typedef int KeyType; // 关键字类型为整数类型

typedef struct {
	KeyType key; // 关键字项
	InfoType otherinfo; // 其它数据项
} RcdType; // 记录类型

typedef struct {
	RcdType r[MAXSIZE+1]; // r[0]闲置
	int length; // 顺序表长度
} SqList; // 顺序表类型
```
## 效率分析
(1) 时间复杂度
	关键字的比较次数和记录移动次数
(2) 空间复杂度
	执行算法所需的附加存储空间
(3) 稳定性

# 插入排序
---
## 直接插入排序
### 实例演示
![](IMG_20231108_144343.jpg)

![[Pasted image 20231108172837.png]]
	从第二个记录开始插入
	第i趟后序列的前i+1个记录是有序的

### 算法
```c
void InsertionSort ( SqList &L ) // 对顺序表 L 作直接插入排序
{
	int i, j;
	for ( i=2; i<=L.length; ++i ) //从2号位置开始
	{	
		if (L.r[i].key < L.r[i-1].key) {
			L.r[0] = L.r[i]; // 复制为监视哨
			L.r[i]=L.r[i-1]; //在满足if情况下，先直接移动一次；若去掉该行，下面for的起始条件改为j=i-1
			for ( j=i-2; L.r[0].key < L.r[j].key; --j )
				L.r[j+1] = L.r[j]; // 记录后移
			L.r[j+1] = L.r[0]; // 插入到正确位置
		}
	}
} // InsertSort
```
### 算法分析
#### 比较与移动的次数
![[Pasted image 20231108173708.png]]
#### 复杂度
a.时间复杂度
	最好情况:比较O(n),移动O(1); 
	最坏情况:比较O(n<sup>2</sup>),移动O(n<sup>2</sup>); 
	平均O(n<sup>2</sup>) 
b.空间复杂度
	O(1)

#### 稳定性
直接插入排序是稳定的排序方法。

## 希尔排序
### 思想
(1)对待排记录序列先作“宏观”调整，再作“微观”调整； 
(2)所谓“宏观”调整，指的是“跳跃式”的插入排序。

![[Pasted image 20231108175704.png]]
### 概述
(1)将记录序列分成若干子序列，分别对每个子序列进行插入排序。 
	例如：将 n 个记录分成 d 个子序列：
	{R[1], R[1+d], R[1+2d], …, R[1+kd]}
	{R[2], R[2+d], R[2+2d], …, R[2+kd]}
	……………………………………
	{R[d], R[d+d], R[d+2d], …, R[d+kd]}
(2)其中d称为增量，它的值在排序过程中从大到小逐渐缩小，直至最后一趟排序减为1。

在增量为d时，希尔排序从d+1个记录开始。
希尔排序完成增量为d的排序后，子序列 L.r[i], L.r[i+d], L.r[i+2d], … , 是有序的，1 $\leq$ i $\leq$ d

### 算法
```c
void ShellInsert ( SqList &L, int dk )//增量为的dk时的希尔
{
	int i, j;
	for ( i=dk+1; i<=L.length; ++i )
	{
		if (LT(L.r[i].key, L.r[i-dk].key))
		{
			L.r[0] = L.r[i]; // 暂存在R[0]
			for (j = i-dk; j > 0 && LT(L.r[0].key, L.r[j].key); j- = dk)
				L.r[j+dk] = L.r[j]; // 记录后移，查找插入位置
			L.r[j+dk] = L.r[0]; // 插入
		}
	}
}
// 对比直接插入算法，用dk代替了1

void ShellSort (SqList &L, int dlta[], int t)
{
	for (k=0; k<t; ++k)
		ShellInsert(L, dlta[k]);//一趟增量为dlta[k]的插入排序
}
```
### 算法分析
#### 稳定性
希尔排序是不稳定的排序方法。
#### 效率
(1)时间复杂度
	平均O(n<sup>1.3</sup>)到平均O(n<sup>1.5</sup>)
(2)空间复杂度
	O(1)

## 折半插入排序
### 思想
(1)在直接插入排序进行到第i个元素时，L.r[1], L.r[2], …, L.r[i-1] 是一个按关键字有序的序列;
(2)可以利用折半查找实现在“L.r[1], L.r[2], …, L.r[i-1]”中查找r[i]的插入位置;
(3)称这种排序为折半插入排序

### 实例演示
![[Pasted image 20231108174153.png]]
### 算法
```c
void BiInsertionSort ( SqList &L )
{
	int i, j;
	for ( i=2; i<=L.length; ++i )
	{
		if (L.r[i].key < L.r[i-1].key)
			L.r[0] = L.r[i]; // 将 L.r[i] 暂存到 L.r[0]
			low = 1; high = i-1;
			while (low<=high) {
				m = (low+high)/2; // 折半
				if (L.r[0].key < L.r[m].key)
					high = m-1; // 插入点在低半区
				else low = m+1; // 插入点在高半区
		for ( j=i-1; j>=high+1; --j )
			L.r[j+1] = L.r[j]; // 记录后移
		L.r[high+1] = L.r[0]; // 插入
	}
}
```
### 算法分析
#### 稳定性
折半插入排序是稳定的排序方法。
#### 效率
a.时间复杂度
	最好情况:比较O(n),移动O(1);
	最坏情况:比较O(log<sub>2</sub> (n!) ),移动O(n<sup>2</sup>); （阶乘是因为对log<sub>2</sub>i求和）
	平均O(n<sup>2</sup>)
b.空间复杂度
	O(1)

# 快速排序
---
## 冒泡排序
### 思想
#### 基本
(1)从第1个记录开始，两两比较， if (L.r[i].key>L.r[i+1].key) then交换； 
(2)第1趟比较结果将序列中关键字最大的记录放置到最后一个位置，称为“沉底”;
(3)n个记录最多比较n-1遍(趟)；最后一趟发生了比较，但没有交换元素

#### 优化
##### 结束条件
如果某趟后序列没有变化，就表示已经排好了。
即冒泡排序的结束条件为：最后一趟没有发生“交换”。
##### 优化方法
用i记录最后一次发生交换的的位置，显然i之后的记录有序。
一般情况下，每经过一趟“起泡”，“i 减一”（但并不是每趟都如此）

### 算法
```c
void BubbleSort(Elem R[ ], int n) //R有效元素位置从1开始，共n个
{
	i = n;//i表示某趟排序得到的最大或最小元素应该放入的位置，初值为n
	while (i >1) {
		lastExchangeIndex = 1;
		for (j = 1; j < i; j++)
			if (R[j+1].key < R[j].key) {
				Swap(R[j], R[j+1]); //交换函数，略
				lastExchangeIndex = j; //记下发生交换的记录的位置
			}
		i = lastExchangeIndex; // i取本趟发生过交换的最后一个记录的位置，表明i之后的记录有序
	}
} 
```
### 算法分析
![[Pasted image 20231108182326.png]]
（1）时间复杂度
	最好情况：比较O(n), 移动O(1)
	最坏情况：比较O(n<sup>2</sup>), 移动O(n<sup>2</sup>)
	平均情况：O(n<sup>2</sup>)
（2）空间复杂度
	O(1)
（3）稳定性
	起泡排序是稳定的排序方法。

## #课件9-2 快速排序
### 基本思想—分治算法
目标：找一个记录，以它的关键字作为“枢轴”，凡其关键字小于枢轴的记录均移动至该记录之前，反之，凡关键字大于枢轴的记录均移动至该记录之后。
致使一趟排序之后，记录的无序序列R[s..t]将分割成两部分： 
R[s..i-1]和R[i+1..t]，且 R[j].key ≤ R[i].key ≤ R[j].key
									   (s≤j≤i-1)     枢轴       (i+1≤j≤t)

#### 示例
![[Pasted image 20231108182942.png]]
![[Pasted image 20231108191235.png]]
![](IMG_20231109_121831.jpg)
先把选为中轴的元素赋值给0号位，low指针指向1号位，high指针指向最后一位；
若h针元素比轴小，则将该元素值赋给l针位置，h针前移一位；
若l针元素比轴小，则将该元素值赋给h针位置，l针后移一位；
直到h、l针指向同一位置，将中轴值赋给该位置，排序结束。

### 算法
```c
int Partition(SqList &L, int low, int high) // 一次快排/一次划分
{
	KeyType pivotkey; // 枢轴位置
	pivotkey = L.r[low].key;
	L.r[0] = L.r[low];
	while (low<high) {
		while (low<high && L.r[high].key>=pivotkey)
			--high;
		L.r[low] = L.r[high];
		while (low<high && L.r[low].key<=pivotkey)
			++low;
		L.r[high] = L.r[low];
	}
	L.r[low] = L.r[0]; // 枢轴记录入位
	return low; // 返回枢轴位置
}

void QSort(SqList &L, int low, int high) //快排递归算法
{
	int pivotloc; //枢轴位置
	if (low < high) {
		pivotloc=Partition(L, low, high); // 将L.r[low..high]一分为二
		QSort(L, low, pivotloc-1); // 对低子表递归快排
		QSort(L, pivotloc+1, high); // 对高子表递归快排
	}
}
```
### 算法分析
#### 时间复杂度
快速排序时间复杂度的平均情况：$O(n\ln n)$
假设一次划分所得枢轴位置 i=k，则对n 个记录进行快排所需时间：T(n) = T<sub>pass</sun>(n)+T(k-1)+T(n-k)，T<sub>pass</sun>(n) 为对n个记录进行一次划分所需时间，和n成正比，可用cn表示。
若待排序列中记录的关键字是随机分布的，则 k 取 1 至 n中任意一值的可能性相同。可得快速排序所需时间的平均值为：
	$T$<sub>avg</sub>$(n)=Cn+\frac{1}{n}\sum\limits_{k=1}^{n}[T$<sub>avg</sub>$(k-1)+T$<sub>avg</sub>$(n-k)]$
	设 $T$<sub>avg</sub> $\leq$ b 则可得结果：$T$<sub>avg</sub>(n)<$(\frac{b}{2}+2c)(n+1)\ln(n+1)$
结论: 快速排序是所有同量级O（nlogn）的排序方法中，平均性能最好的。
最坏情况:每一轮排序的轴枢始终位于一端,如:n,…2,1。一直两两比较和移动，退化为起泡排序,O(n<sup>2</sup>) 。
#### 稳定性
快速排序是不稳定的排序方法

### 算法改进
若待排记录的初始状态为按关键字有序时，快速排序将蜕化为起泡排序，其时间复杂度为O(n<sup>2</sup>) （当初始数据较为有序时用冒泡排序更好）
为避免出现这种情况，需在进行一次划分之前，进行“预处理”，即： 
	先对 R(s).key, R(t).key 和 R$[\frac{s+t}{2}]$.key，进行相互比较，然后取关键字为 “三者之中”的记录为枢轴记录。
	再拿“三者之中”和R[S]交换
	最后，按照前面的算法进行快排即可

# 选择排序
---
## 简单选择排序
### 思想
设需要排序的表是R[n+1],0号空间不用: 
(1)第一趟排序是在R[1..n]中选出关键字最小的记录,将它与R[1] 交换,确定最小值; 
(2)第二趟排序是在R[2..n]中选关键字最小的记录,将它与R[2]交 换,确定次小值； 
(3)第i趟排序是在R[i..n]中选关键字最小的记录,将它与R[i]交换; 
(4)共n-1趟。
![[Pasted image 20231110223349.png]]

### 算法概要
```c
void SelectSort (Elem R[], int n ) {// 对记录R[1..n]简单选择排序。
	for (i=1; i<n; ++i) {//共n-1趟
		j = SelectMinKey(R, i)// 在 R[i..n] 中选择关键字最小的记录
		if (i!=j) R[i]←→R[j];// 与第 i 个记录交换
	}
}
```
### 算法
```c
void SelectSort(SqList L){
	int i, j, min;//min存储L.r[i...n]中最小值的下标
	for(i=1; i<L.length; i++) {
		min = i;//min初值为i
		for(j=i+1; j<=L.length; j++)
			if(L.r[j].key < L.r[min].key)
				min = j;
		if(min != i) { //如果min较比初值发生变化，则交换
			L.r[0]=L.r[i];
			L.r[i]=L.r[min];
			L.r[min]=L.r[0];
		}
	}
}
```
### 算法分析
(1)稳定性
	简单选择排序方法是不稳定的。
	（可能会交换值相同的元素，交换后破坏了它们原本的相对顺序）
(2)时间复杂度
	比较O(n2 ),移动最好O(1),最差O(n)。分析如下：
		对 n 个记录进行简单选择排序，所需进行的关键字间的比较次数总计为：
			 $\sum\limits_{i=1}^{n-1}(n-i)=\frac{n(n-1)}{2}$
		移动记录的次数，最小值为 0, 最大值为3(n-1) 。
(3)空间复杂度为O(1)。

## 堆排序
### 引入
![[Pasted image 20231110224550.png]]
堆排序属于选择排序:出发点是利用选择排序已经发生过的比较，记住比较的结果，减少重复“比较”的次数。

### 堆的定义
n个元素的关键字序列R[1].key, R[2].key, … , R[n].key， 当且仅当满足下述关系时，称之为堆。
	小根堆：
		R[i].key≤R[2*i].key 且 R[i].key≤R[2*i+1].key，即根结点数据比左右子结点小
	大根堆：
		R[i].key≥R[2*i].key 且 R[i].key≥R[2*i+1].key，即根结点数据比左右子结点大
![[Pasted image 20231110224843.png]]

### 堆排序的宏观过程
![[Pasted image 20231110224938.png]]
交换根与树顶元素，排除树顶元素后再对新树重新排序为根堆
### 堆排序的关键问题
(1) 建堆：由一个无序序列建成一个堆。 
(2) 调整：一轮交换后，调整R[1..i-1] 成为一个新的堆,这个过程也称为筛选。
### 堆排序的筛选过程
![[Pasted image 20231110225251.png]]
	22被放入临时空间

### 堆排序的筛选算法
```c
void HeapAdjust(HeapType &H, int s, int m) //将R[s..m]调整成堆
{
	int j;
	RedType rc=H.r[s];//暂存r[s]到rc
	for (j=2*s; j<=m; j*=2) { //j的初值为r[s]的左孩子,循环一次后j翻倍即指向其左孩子
		if (j<m && H.r[j].key<H.r[j+1].key)//横比r[s]的两个孩子
			++j; //如果右孩子大于左孩子,j指向右孩子。最终j指向r[s]的最大孩子
		if (rc.key>= H.r[j].key) break;//纵比,如果rc最大，结束循环
		H.r[s] = H.r[j]; //r[j]最大，放入r[s]
		s = j;//s变为j, 然后进入下一次循环j*=2,进入下一层 ,继续寻找rc应放的位置
	}
	H.r[s] = rc; // 将rc放入应放的位置r[s]中
} // HeapAdjust
```
### 建堆
![[Pasted image 20231113172057.png]]

### 堆排序算法概要
(1) 建堆。先将无序序列R[1..n]映射为完全二叉树，然后从最后一个非叶子结点开始到根，将R[1..n]依次调整成堆; 
(2) for i from n to 2：
	交换堆顶元素R[1]与最后一个元素R[i]; 
	前i-1个元素不再满足堆的特性,通过调整重建堆;
![[Pasted image 20231113172205.png]]

### 堆排序算法
```c
void HeapSort(HeapType &H) {
	int i;
	RcdType temp;
	for (i=H.length/2; i>0; --i) //建堆
		HeapAdjust ( H, i, H.length );
	for (i=H.length; i>1; --i) {
		temp=H.r[i]; H.r[i]=H.r[1]; H.r[1]=temp; //交换
		HeapAdjust(H, 1, i-1); //调整R[1..i-1]
	}
} // HeapSort
```
### 算法分析
(1)堆排序是不稳定的排序。 
(2)时间复杂度为O(n$log$<sub>2</sub>n)。 
	最坏情况下时间复杂度为O(n$log$<sub>2</sub>n) 。
	①对深度为 k 的堆，“筛选”所需进行的关键字比较的次数至多为2(k-1)；从第2层开始进行筛选，每层进行横比和纵比各1次 
	②对 n 个关键字，建成深度为h(=$log$<sub>2</sub>n+1)的堆，所需进行的关键字比较的次数至多 4n； 
	③调整“堆顶” n-1 次，总共进行的关键字比较的次数不超过： 
		2 ($log$<sub>2</sub>(n-1)+ $log$<sub>2</sub>(n-2)+…+$log$<sub>2</sub>2) < 2n$log$<sub>2</sub>n
		因此，堆排序的时间复杂度为O(nlogn)。 
(3)空间复杂度为O(1)。

## 树形选择排序（自学）

# 归并排序
---
## 定义
也称合并,把两个或两个以上的有序序列合并成一个有序序列。
![[Pasted image 20231113173222.png]]

## 归并算法
```c
void Merge (RcdType SR[], RcdType TR[], int i, int m, int n) {
	int j,k;
	for (j=m+1, k=i; i<=m && j<=n; ++k) {
		if (LQ(SR[i].key, SR[j].key))
			TR[k] = SR[i++];
		else TR[k] = SR[j++];
	}
	if (i<=m)
		while (k<=n && i<=m)
			TR[k++]=SR[i++];
	if (j<=n)
		while (k<=n &&j <=n)
			TR[k++]=SR[j++];
} // Merge
```
将两个长度分别为n，m的递增有序顺序表归并成一个有序顺序表，其元素最多比较m+n-1次
## 递归的2-路归并排序
### 思想
无序序列R[s..t]的两部分R`[`s..$\frac{s+t}{2}$`]`和R`[`$\frac{s+t}{2}$+1..t`]`如果分别按关键字有序，则利用前面的归并算法将它们归并成一个有序序列。
由此，应该先分别对这两部分进行 2-路归并排序。
![[Pasted image 20231113174225.png]]

### 算法
```c
void Msort ( RcdType SR[], RcdType &TR1[], int s, int t ) {
	// 将SR[s..t] 归并排序为 TR1[s..t]
	if (s==t) TR1[s]=SR[s];//如果长度为1，直接赋值，递归结束
	else{ 
		m = (s+t)/2; // 将SR[s..t]平分为SR[s..m]和SR[m+1..t]
		Msort (SR, TR2, s, m); // 递归地将SR[s..m]归并为有序的TR2[s..m]
		Msort (SR, TR2, m+1, t); //递归地SR[m+1..t]归并为有序的TR2[m+1..t]
		Merge (TR2, TR1, s, m, t); // 将TR2[s..m]和TR2[m+1..t]归并到TR1[s..t]
	}
}
void MergeSort (SqList &L) {
	// 再封装,对表L进行2-路归并排序
	MSort(L.r, L.r, 1, L.length);
} // MergeSort
```
## 非递归的2-路归并排序
### 思想
(1) 初始：将n个记录分成n个长度为1的有序子表； 
(2) 归并两两相邻的有序子表，若子表数为奇数，则留下的一个子表直接进入下一次归并； 
(3) 重复步骤(2)，直到归并成一个长度为n的有序表。

如:序列25，57，48，37，12，92，86的非递归2-路归并排序为:
![[Pasted image 20231113175735.png]]
归并排序总共需要$log$<sub>2</sub>n趟

### 算法
(1) 设有序子表长为 l ，则 1 到 l 是有序的，l+1 到 2l 也有序; 
	设i是某子表的起点,则 i 到 i+l-1 有序,同时 i+l 到 i+2l -1也有序。 
(2) 两两归并。Merge (SR[], TR[], i, i+ l -1, i+2 l -1),i从1开始
![[Pasted image 20231113174942.png]]
```C
void Msort(RcdType A[],RcdType B[],int n, int l) {
	int i=1,t;
	while (i + 2* l - 1 < = n){
		Merge (A, B, i, i+l-1, i+2*l-1)
		i = i + 2*l;
	}
	if (i+l-1<n)
		Merge(A, B, i, i+l-1, n);
	else
		for (t=i; t<=n; t++)  B[t]=A[t];
}
void MergeSort(RcdType A[],int n) {
	//再封装,对表 L进行非递归的2-路归并排序
	int l=1;
	Rcdtype B[];
	while (l<n){
		Msort(A,B,n,l);
		l=2*l;
		if (l>=n) break;
		Msort(B,A,n,l);
		l=2*l;
	}
}
```
## 2-路归并排序算法分析
(1) 稳定性
	归并排序是稳定的排序方法。 
(2) 时间复杂度
	每趟归并所花时间比较移动都是O(n)； 
	归并趟数为$log$<sub>2</sub>n; 
	时间复杂度为O(n$log$<sub>2</sub>n)。 
(3) 空间复杂度是O(n)。

## k-路归并排序
k路归并排序共需要 $log$<sub>k</sub>n 趟
k路归并排序的时间复杂性是 n$log$<sub>k</sub>n

# #课件9-3 基数排序
---
## 基数排序的起源
(1)基数排序起源于箱(桶)排序，桶排序的过程是：
	设置若干个箱子（桶）, 依次扫描待排序的记录,A[1],A[2],…,A[n],把关键字为k的记录放在第k个箱子里,按序号将非空的箱子里的记录收集起来。 
(2)箱(桶)排序的缺点：如果关键字位数太大，这样做空间复杂性和时间复杂性都太大。
![[Pasted image 20231113180559.png]]

## 链式基数排序
### 思想
称以链表作为存储结构的基数排序为链式基数排序，这样能减少排序的辅助空间。算法思想为：
(1)建立待排序记录链表
(2)分配：按当前“关键字位”所取值，将记录分配到不同的“链队列”中，每个队列中记录的 “关键字位” 相同；
(3)收集：按关键字位取值从小到大将各队列首尾相链成一个链表;
(4)对后面各个关键字位重复(2)和 (3) 两步。
### 实例
写出对序列369，367，167，239，237，138，230，139进行链式基数排序的过程：
待排序记录链表: p→369→367→167→239→237→138→230→139

第一次分配：按关键字的个位分配
	f[0]→230←r[0]
	f[7]→367→167→237←r[7]
	f[8]→138←r[8]
	f[9]→369→239→139←r[9]
第一次收集：p→230→367→167→237→138 →368→239→139

第二次分配：基于第一次收集的结果，按关键字的十位分配
	f[3]→230→237→138→239→139←r[3]
	f[6]→367→167→368←r[6]
第二次收集: p→230→237→138→239→139→367→167→368

第三次分配：基于第二次收集的结果，按关键字的百位分配
	f[1]→138→139→167←r[1] 
	f[2]→230→237→239←r[2]
	f[3]→367→368←r[3]
第三次收集：p→138→139→167→230→237→239→367→368
得到最终的有序序列

基数排序共需多少趟分配和收集？ 
	——结果为最大关键字的位数
### 算法概要
设待排记录A的关键字最大是figure位的正整数。
设pass为关键字的位号,个位的位号为1，对各个位作如下处理:
for(pass=1;pass<=figure;pass++){
	分配:pass位值为0的关键字插入队列Q[0],…,为9的插入Q[9]；
	收集:将Q[0],…,Q[9]中的数据依次收集到A[]中；
}
### 算法
```c
void radixsort(int figure,QUEUE &A){//关键字链表用队列存储
	QUEUE Q[10];records data;
	int pass,r,i; //pass用于位数循环,r取位数
	for(pass=1;pass<=firure;pass++) {
		for(i=0;i<=9;i++) MAKENULL(Q[i]) // 把10个队列置空
		while(!EMPTY(A)) {
			data=FRONT(A);//获取A中的需要处理的数据给data
			DEQUEUE(A);//data从A中出队
			r=((data.key/pow (10,pass-1))%10);//计算第pass位的值给r
			ENQUEUE(data,Q[r]);//把data插入队列Q[r]
		}
		for(i=1;i<=9;i++) CONCATENATE(Q[0],Q[i]);//收集
		A=Q[0];//收集的结果赋给A
	}
}
//收集算法
void CONCATENATE(QUEUE &Q[0], QUEUE &Q[1]){
	if(!EMPTY(Q[1])){
		Q[0].rear->next=Q[1].front->next;
		Q[0].rear=Q[1].rear;
	}
}
```
### 算法分析
基数排序是稳定的
时间复杂性为O(n)
	设关键字位数为d,基为rd，时间复杂性为O(d*(n+rd))；又考虑到d和rd是一个常数，因此，时间复杂性为O(n)
	分配的时间复杂性为O(n)
	收集的时间复杂性为O(rd)
空间复杂性为O(n)。

# 各方法的比较
---
![[Pasted image 20231113184023.png]]

# 本章小结
---
熟练掌握：直接插入排序、希尔排序、冒泡排序、快速排序、简单选择排序、堆排序、归并排序、基数排序的思想和算法。充分了解各种排序算法的应用背景和优缺点。 
加强各种排序算法在实际应用中的训练，提高实际应用水平。