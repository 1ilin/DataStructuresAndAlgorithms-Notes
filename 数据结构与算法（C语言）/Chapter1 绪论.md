# 大纲
![](Pasted%20image%2020231124124938.png)
图形图像和人工智能 软工不学
![](Pasted%20image%2020231124130843.png)
红色部分不学不考 树和图是重点

![](5@quickNote_1693377404425.jpg_230830_143650_291.jpg)
![](6@quickNote_1693377427966.jpg_230830_143713_383.jpg)

# 什么是数据结构
---
数据结构是数据对象在计算机中的组织方式,形式定义为一个二元组Data_Structure=(D,S),D是数据元素的有限集即数据对象，S是D上关系的有限集。或者说，数据结构是相互之间存在着某种逻辑关系的数据元素的集合。
◼ 逻辑结构 
	 数据对象的逻辑组织关系。分为线性、树、图、集合。 
	 如图书的随便摆放就是线性结构，分区摆放就是树形结构
◼ 物理存储结构 
	 数据对象在计算机内存中的存储组织关系——逻辑结构在存储 器中的映象。 
		◼ 数据元素的映象：数据在内存中以二进制存储 
		◼ 关系的映象：有序对，所有关系都可表示为有序对的集合 
	 分为顺序存储和链式存储

有序对的顺序存储：以相对的存储位置表示后继关系 
	◼ 例如:令 y 的存储位置和 x 的存储位置之间差一个常量 C ，而 C 是一个隐含值，整个存储结构中只含数据元素本身的信息  （数组）
有序对的链式存储：以附加信息(指针)表示后继关系 
	◼ 需要用一个和 x 在一起的附加信息指示 y 的存储位置  （链表）
![](Pasted%20image%2020231124131217.png)
![](Pasted%20image%2020231124131236.png)
![](Pasted%20image%2020231124131304.png)
 数据对象：实际问题中计算机要处理的事务。 
	◼ 所有能被输入到计算机中，且能被计算机处理的符号的集合。 
	◼ 是计算机操作的对象的总称。 
	◼ 是计算机处理的信息的某种特定的符号表示形式。 
	◼ 如图书摆放问题中的图书就是数据对象 
 数据元素 
	◼ 是数据（集合）中的一个“个体” 
	◼ 是数据结构中讨论的基本单位
 数据项 
	◼ 是数据结构中讨论的最小单位 
	◼ 数据元素可以是数据项的集合 
	◼ 如：描述一个运动员的数据元素可以是
		姓名 俱乐部名称 出生日期 参加日期 职务 业绩
		出生日期包含年月日，称为组合项
# 抽象数据类型
---
 数据类型：数据对象的类型确定了其数据定义域和操作集 
 抽象数据类型：是指一个数学模型以及定义在此数学模型上的一组操作（D,S,P），突出抽象和封装，强调本质特征。数据对象+关系集+操作集 
	◼ “抽象”的意思，是指我们描述数据类型的方法是不依赖于具体实现的 
	◼ 即数据对象集和操作集的描述与存放数据的机器无关、与数据存储的物理结构无关、与实现操作的算法和编程语言均无关。 
	◼ 简而言之，抽象数据类型只描述数据对象集和相关操作集“是什么”，并不涉及“如何做到”的问题。
```c
ADT 抽象数据类型名 { 
	数据对象D：〈数据对象的定义〉 
	数据关系S：〈数据关系的定义〉 
	基本操作P：〈基本操作的定义〉 
} ADT 抽象数据类型名
```
其中基本操作的定义格式为: 
	基本操作名（参数表） 
		初始条件：〈初始条件描述〉 
		操作结果：〈操作结果描述〉

赋值参数 
	只为操作提供输入值。 
引用参数 
	以&打头，除可提供输入值外，还将返回操作结果。 
初始条件 
	描述了操作执行之前数据结构和参数应满足的条件，若不满足，则操作失败，并返回相应出错信息。 
操作结果 
	说明了操作正常完成之后，数据结构的变化状况和应返回的结果。若初始条件为空，则省略之。

抽象数据类型的表示和实现 
	抽象数据类型需要通过固有数据类型(高级编程语言中已实现的数据类型)来实现。
复数的ADT实现示例：
```c
// -----存储结构的定义
typedef struct { 
	float realpart； 
	float imagpart； 
}complex；
// -----基本操作的函数原型说明 
void Assign( complex &Z, float realval, float imagval )； // 构造复数 Z,其实部和虚部分别被赋以参数realval和imagval的值
float GetReal( cpmplex Z )； // 返回复数 Z 的实部值 
float Getimag( cpmplex Z )； // 返回复数 Z 的虚部值 
void add( complex z1, complex z2, complex &sum )； // 以 sum 返回两个复数 z1, z2 的和
// -----基本操作的实现 
void add( complex z1, complex z2, complex &sum ) { // 以 sum 返回两个复数 z1, z2 的和 
	sum.realpart = z1.realpart + z2.realpart; 
	sum.imagpart = z1.imagpart + z2.imagpart; 
}
{ 其它省略 }
```

# 算法复杂度
---
 数据对象必定与一系列加在其上的操作相关联 
	◼ 如查找、插入、删除、修改、求值、… 
 完成这些操作所用的方法就是算法 
	◼ 通常一个算法用一个函数来实现。 
	◼ 用空间复杂度和时间复杂度来评价算法
## 空间复杂度S(n)
根据算法写成的程序在执行时占用存储单元的长度。这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断
![](Pasted%20image%2020231124132804.png)

## 时间复杂度T(n)
根据算法写成的程序在执行时耗费时间的长度。这个长度往往也与输入数据的规模有关。时间复杂度过高的低效算法可能导致我们在有生之年都等不到运行结果
![](Pasted%20image%2020231124132827.png)
![](Pasted%20image%2020231124132851.png)

## 算法复杂度的渐进表示法
 如何来“度量”一个算法的时间复杂度呢？ 
	◼ 首先，它应该与运行该算法的机器和编译器无关； 
	◼ 其次，它应该与要解决的问题的规模 n 有关；（有时，描述一个问题的规模需要多个参数） 
	◼ 再次，它应该与算法的“1步”执行需要的工作量无关！ 
	◼ 所以，在描述算法的时间性能时，人们只考虑宏观渐近性质，即当输入问题规模 n “充分大”时，观察算法复杂度随着 n 的“增长趋势”：当变量n不断增加时，解决问题所需要的时间的增长关系。 
 比如 
	◼ 线性增长 T(n) = c·n 
		 即问题规模n增长到2倍、3倍……时，解决问题所需要的时间 T(n)也是增长到2倍、3倍……（ 与c无关 ） 
	◼ 平方增长： T(n) = c·n<sup>2</sup> 
		 即问题规模n增长到2倍、3倍……时，解决问题所需要的时间 T(n)增长到4倍、9倍…… （ 与c无关 ）

 对给定的算法做渐进分析时，有几个小窍门： 
	(1) 若干层嵌套循环的时间复杂度等于各层循环次数的 乘积再乘以循环体代码的复杂度。
		例如下列2层嵌套循环的复杂度是O(N2)： 
			`for ( i=0; i<N; i++ ) `
				`for ( j=0; j<N; j++ ) `
				`{ x = y*x + z; k++; }`
	(2) if-else 结构的复杂度取决于if的条件判断复杂度和 两个分枝部分的复杂度，总体复杂度取三者中最大。
			`if (P1) // P1的复杂度为 O(f1) `
				 `P2; // P2的复杂度为 O(f2) `
			`else P3; // P3的复杂度为 O(f3) `
			总复杂度为 max( O(f1), O(f2), O(f3) ) 。

### 渐进上界
◼ T (n) = O(g(n)) 表示存在常数c > 0, n0 > 0 ，使得 当 n ≥ n0 时有 T (n) ≤ c g(n) 
	 秦九韶算法的时间复杂度是O(n) ， 
	 而简单直接法的时间复杂度是O(n<sup>2</sup> ) 。
![](Pasted%20image%2020231124133233.png)
### 渐进下界
◼ T (n) = Ω(g(n)) 表示存在常数c > 0, n0 > 0 ，使得 当 n ≥ n0 时有 T (n) ≥ c g(n)
![](Pasted%20image%2020231124133325.png)
### 渐进确界
◼ T (n) = Θ(h(n)) 表示
	T (n) = O(h(n)) 同时T (n) = Ω(h(n))
![](Pasted%20image%2020231124133430.png)

## 常用复杂度函数
常用函数增长表
![](Pasted%20image%2020231124133922.png)
![](Pasted%20image%2020231124133945.png)
![](Pasted%20image%2020231124134006.png)

# 算法
---
算法是为了解决某类问题而规定的一个有限长的操作序列。
## 算法的特性
一个算法必须满足以下五个重要特性：
### 1．有穷性 
对于任意一组合法输入值，在执行有穷步骤之后一定能结束，即： 算法中的每个步骤都能在有限时间内完成。 
### 2．确定性 
对于所应执行的每个操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径，对于相同的输入只能得到相同的输出。
### 3．可行性 
算法中的所有操作都可以通过已经实现的基本操作运算有限次实现。 
### 4．有输入 
作为算法加工对象，通常体现为算法中的一组变量。有些输入量需要在算法执行过程中输入， 而有的算法表面上可以没有输入，实际上已被嵌入算法之中。 
### 5．有输出 
它是一组与“输入”有确定关系的量值， 是算法进行信息加工后得到的结果，这种确定关系即为算法的功能。

## 算法的设计原则
设计算法时，通常应考虑达到以下目标：
### 1．正确性 
首先，算法应当满足以特定的“规格说明”方式给出的需求。 
其次，对算法是否“正确”的理解可以有以下四个层次： 
	a．程序中不含语法错误； 
	b．程序对于几组输入数据能够得出满足要求的结果； 
	c．程序对于精心选择的、典型、苛刻且带有刁难性的几组输入数据能够得出满足要求的结果； 
	d．程序对于一切合法的输入数据都能得出满足要求的结果； 通常以第 c 层意义的正确性作为衡量一个算法是否 合格的标准。
### 2. 可读性 
算法主要是为了人的阅读与交流，其次才是为计算机执行，因此算法应该易于人的理解；另一方面，晦涩难读的程序易于隐藏较多错误而难以调试。
### 3 .健壮性 
当输入的数据非法时，算法应当恰当地作出反映或进行相应处理，而不是产生莫名奇妙的输出结果。 并且，处理出错的方法不应是中断程序的执行，而应是返回一个表示错误或错误性质的值，以便在更高的抽象层次上进行处理。
### 4 .高效率与低存储量需求 
通常，效率指的是算法执行时间； 存储量指的是算法执行过程中所需的最大存储空间， 两者都与问题的规模有关。
